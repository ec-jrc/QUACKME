import { Action, ActionCreator, Creator } from '@ngrx/store';
import { Observable, OperatorFunction, Operator } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare class Actions<V = Action> extends Observable<V> {
    constructor(source?: Observable<V>);
    lift<R>(operator: Operator<V, R>): Observable<R>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Actions<any>, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Actions<any>>;
}
declare type ActionExtractor<T extends string | AC, AC extends ActionCreator<string, Creator>, E> = T extends string ? E : ReturnType<Extract<T, AC>>;
/**
 * 'ofType' filters an Observable of Actions into an observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 */
export declare function ofType<AC extends ActionCreator<string, Creator>[], U extends Action = Action, V = ReturnType<AC[number]>>(...allowedTypes: AC): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, U extends Action = Action, V = T1 extends string ? E : ReturnType<Extract<T1, AC>>>(t1: T1): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2, AC, E>>(t1: T1, t2: T2): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3, AC, E>>(t1: T1, t2: T2, t3: T3): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3 | T4;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4): OperatorFunction<U, V>;
export declare function ofType<E extends Extract<U, {
    type: T1 | T2 | T3 | T4 | T5;
}>, AC extends ActionCreator<string, Creator>, T1 extends string | AC, T2 extends string | AC, T3 extends string | AC, T4 extends string | AC, T5 extends string | AC, U extends Action = Action, V = ActionExtractor<T1 | T2 | T3 | T4 | T5, AC, E>>(t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): OperatorFunction<U, V>;
/**
 * Fallback for more than 5 arguments.
 * There is no inference, so the return type is the same as the input -
 * Observable<Action>.
 *
 * We provide a type parameter, even though TS will not infer it from the
 * arguments, to preserve backwards compatibility with old versions of ngrx.
 */
export declare function ofType<V extends Action>(...allowedTypes: Array<string | ActionCreator<string, Creator>>): OperatorFunction<Action, V>;
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5kLnRzIiwic291cmNlcyI6WyJhY3Rpb25zLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb24sIEFjdGlvbkNyZWF0b3IsIENyZWF0b3IgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9uLCBPcGVyYXRvciB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWN0aW9uczxWID0gQWN0aW9uPiBleHRlbmRzIE9ic2VydmFibGU8Vj4ge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZT86IE9ic2VydmFibGU8Vj4pO1xuICAgIGxpZnQ8Uj4ob3BlcmF0b3I6IE9wZXJhdG9yPFYsIFI+KTogT2JzZXJ2YWJsZTxSPjtcbn1cbmRlY2xhcmUgdHlwZSBBY3Rpb25FeHRyYWN0b3I8VCBleHRlbmRzIHN0cmluZyB8IEFDLCBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPiwgRT4gPSBUIGV4dGVuZHMgc3RyaW5nID8gRSA6IFJldHVyblR5cGU8RXh0cmFjdDxULCBBQz4+O1xuLyoqXG4gKiAnb2ZUeXBlJyBmaWx0ZXJzIGFuIE9ic2VydmFibGUgb2YgQWN0aW9ucyBpbnRvIGFuIG9ic2VydmFibGUgb2YgdGhlIGFjdGlvbnNcbiAqIHdob3NlIHR5cGUgc3RyaW5ncyBhcmUgcGFzc2VkIHRvIGl0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgYWN0aW9uc2AgaGFzIHR5cGUgYEFjdGlvbnM8QWRkaXRpb25BY3Rpb258U3Vic3RyYWN0aW9uQWN0aW9uPmAsIGFuZFxuICogdGhlIHR5cGUgb2YgdGhlIGBBZGRpdGlvbmAgYWN0aW9uIGlzIGBhZGRgLCB0aGVuXG4gKiBgYWN0aW9ucy5waXBlKG9mVHlwZSgnYWRkJykpYCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlPEFkZGl0aW9uQWN0aW9uPmAuXG4gKlxuICogUHJvcGVybHkgdHlwaW5nIHRoaXMgZnVuY3Rpb24gaXMgaGFyZCBhbmQgcmVxdWlyZXMgc29tZSBhZHZhbmNlZCBUUyB0cmlja3NcbiAqIGJlbG93LlxuICpcbiAqIFR5cGUgbmFycm93aW5nIGF1dG9tYXRpY2FsbHkgd29ya3MsIGFzIGxvbmcgYXMgeW91ciBgYWN0aW9uc2Agb2JqZWN0XG4gKiBzdGFydHMgd2l0aCBhIGBBY3Rpb25zPFNvbWVVbmlvbk9mQWN0aW9ucz5gIGluc3RlYWQgb2YgZ2VuZXJpYyBgQWN0aW9uc2AuXG4gKlxuICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3aGVuIG9uZSBwYXNzZXMgYSBzaW5nbGUgdHlwZSBhcmd1bWVudFxuICogYG9mVHlwZTxUPignc29tZXRoaW5nJylgIHRoZSByZXN1bHQgaXMgYW4gYE9ic2VydmFibGU8VD5gLiBOb3RlLCB0aGF0IGBUYFxuICogY29tcGxldGVseSBvdmVycmlkZXMgYW55IHBvc3NpYmxlIGluZmVyZW5jZSBmcm9tICdzb21ldGhpbmcnLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIGZvciB1bmtub3duICdhY3Rpb25zOiBBY3Rpb25zJyB0aGVzZSB0eXBlcyB3aWxsIHByb2R1Y2VcbiAqICdPYnNlcnZhYmxlPG5ldmVyPicuIEluIHN1Y2ggY2FzZXMgb25lIGhhcyB0byBtYW51YWxseSBzZXQgdGhlIGdlbmVyaWMgdHlwZVxuICogbGlrZSBgYWN0aW9ucy5vZlR5cGU8QWRkaXRpb25BY3Rpb24+KCdhZGQnKWAuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPltdLCBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLCBWID0gUmV0dXJuVHlwZTxBQ1tudW1iZXJdPj4oLi4uYWxsb3dlZFR5cGVzOiBBQyk6IE9wZXJhdG9yRnVuY3Rpb248VSwgVj47XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBvZlR5cGU8RSBleHRlbmRzIEV4dHJhY3Q8VSwge1xuICAgIHR5cGU6IFQxO1xufT4sIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LCBUMSBleHRlbmRzIHN0cmluZyB8IEFDLCBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLCBWID0gVDEgZXh0ZW5kcyBzdHJpbmcgPyBFIDogUmV0dXJuVHlwZTxFeHRyYWN0PFQxLCBBQz4+Pih0MTogVDEpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gb2ZUeXBlPEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHtcbiAgICB0eXBlOiBUMSB8IFQyO1xufT4sIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LCBUMSBleHRlbmRzIHN0cmluZyB8IEFDLCBUMiBleHRlbmRzIHN0cmluZyB8IEFDLCBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLCBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIsIEFDLCBFPj4odDE6IFQxLCB0MjogVDIpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gb2ZUeXBlPEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHtcbiAgICB0eXBlOiBUMSB8IFQyIHwgVDM7XG59PiwgQUMgZXh0ZW5kcyBBY3Rpb25DcmVhdG9yPHN0cmluZywgQ3JlYXRvcj4sIFQxIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFQyIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFQzIGV4dGVuZHMgc3RyaW5nIHwgQUMsIFUgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24sIFYgPSBBY3Rpb25FeHRyYWN0b3I8VDEgfCBUMiB8IFQzLCBBQywgRT4+KHQxOiBUMSwgdDI6IFQyLCB0MzogVDMpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gb2ZUeXBlPEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHtcbiAgICB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNDtcbn0+LCBBQyBleHRlbmRzIEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPiwgVDEgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDIgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDMgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVDQgZXh0ZW5kcyBzdHJpbmcgfCBBQywgVSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbiwgViA9IEFjdGlvbkV4dHJhY3RvcjxUMSB8IFQyIHwgVDMgfCBUNCwgQUMsIEU+Pih0MTogVDEsIHQyOiBUMiwgdDM6IFQzLCB0NDogVDQpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gb2ZUeXBlPEUgZXh0ZW5kcyBFeHRyYWN0PFUsIHtcbiAgICB0eXBlOiBUMSB8IFQyIHwgVDMgfCBUNCB8IFQ1O1xufT4sIEFDIGV4dGVuZHMgQWN0aW9uQ3JlYXRvcjxzdHJpbmcsIENyZWF0b3I+LCBUMSBleHRlbmRzIHN0cmluZyB8IEFDLCBUMiBleHRlbmRzIHN0cmluZyB8IEFDLCBUMyBleHRlbmRzIHN0cmluZyB8IEFDLCBUNCBleHRlbmRzIHN0cmluZyB8IEFDLCBUNSBleHRlbmRzIHN0cmluZyB8IEFDLCBVIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uLCBWID0gQWN0aW9uRXh0cmFjdG9yPFQxIHwgVDIgfCBUMyB8IFQ0IHwgVDUsIEFDLCBFPj4odDE6IFQxLCB0MjogVDIsIHQzOiBUMywgdDQ6IFQ0LCB0NTogVDUpOiBPcGVyYXRvckZ1bmN0aW9uPFUsIFY+O1xuLyoqXG4gKiBGYWxsYmFjayBmb3IgbW9yZSB0aGFuIDUgYXJndW1lbnRzLlxuICogVGhlcmUgaXMgbm8gaW5mZXJlbmNlLCBzbyB0aGUgcmV0dXJuIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhlIGlucHV0IC1cbiAqIE9ic2VydmFibGU8QWN0aW9uPi5cbiAqXG4gKiBXZSBwcm92aWRlIGEgdHlwZSBwYXJhbWV0ZXIsIGV2ZW4gdGhvdWdoIFRTIHdpbGwgbm90IGluZmVyIGl0IGZyb20gdGhlXG4gKiBhcmd1bWVudHMsIHRvIHByZXNlcnZlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIHZlcnNpb25zIG9mIG5ncnguXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9mVHlwZTxWIGV4dGVuZHMgQWN0aW9uPiguLi5hbGxvd2VkVHlwZXM6IEFycmF5PHN0cmluZyB8IEFjdGlvbkNyZWF0b3I8c3RyaW5nLCBDcmVhdG9yPj4pOiBPcGVyYXRvckZ1bmN0aW9uPEFjdGlvbiwgVj47XG5leHBvcnQge307XG4iXX0=